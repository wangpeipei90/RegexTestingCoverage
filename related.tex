\section{Related Work}
\label{sec:related}
Regular expressions are used widely in software programs~\cite{chapman2016} but are often difficult to understand and error-prone~\cite{chapman2017exploring}. Prior work on regular expression comprehension~\cite{chapman2017exploring} raises a concern about how well the regular expressions used in programs are tested. Although there are papers on program test coverage, none of them have specifically discussed testing regular expressions.

Software test coverage can be measured at different levels of granularity, such as method, statement, branch, system, integration, module, and unit (e.g.,~\cite{malaiya2002software, ammann2016introduction, zhu1997software,li2009experimental,piwowarski1993coverage}). Symbolic execution~\cite{klee,jpf,xie2005symstra,bucur2011parallel} is one way to generate inputs and to obtain program test coverage at the level of branches. There are many tools for automated test generation~\cite{zhang2011combined,fraser2013does,pacheco2007randoop}. For example, Reggae~\cite{li2009reggae} aims to mitigate the large space exploration issues in generating test inputs for programs with regular expressions. %Instead of exploring all possibilities of input strings, it synthesizes the matching method into if-else branches.

With respect to the finite automaton constructed from regular expressions, {\tt brics}~\cite{brics} contains a DFA implementation with very limited operations; while RE2~\cite{cox2007regular,re2} provides a DFA implementation which runs much faster than traditional regular expression engines in Java, Perl, and Python. Rex~\cite{rex} builds a symbolic representation of finite automata (SFA). Some string solvers~\cite{kiezun2009hampi} and tools for generating testing inputs which use string solvers~\cite{wassermann2008dynamic,Ghosh:2013:JAT:2486788.2486925} build finite-state automata based on string constraints.

Visualizations to aid debugging~\cite{beck2014regviz,regex101} are also powerful techniques for regular expression comprehension, and may provide some explanation for low test coverage of regular expressions in source code, that is, developers use online tools instead. 

Other techniques and tools have been developed in string generation or regular expression extraction for system fault detection and performance optimization. Rex~\cite{rex} generates testing inputs for the regular expression according to its SFA representation. {\tt brics}~\cite{brics} generates inputs by traversing the DFA and building strings from the smallest bytes to the largest bytes of every DFA states. 
Some string generation tools need user-specified string length~\cite{kiezun2009hampi, brics, Ghosh:2013:JAT:2486788.2486925}. EGRET~\cite{larson2016generating} is focused on generating unexpected test strings to expose the regular expression errors, but it is based on common mistakes when creating regular expression rather than maximizing test coverage of regular expressions. MUTREX~\cite{7899040} employs distinguishing strings which can separate a mutated regular expression from the original one to expose system faults. Genetic programming has also been applied~\cite{cody2017search} to find equivalent alternative regular expressions which exhibit improved performances. %ReLIE~\cite{li2008regular} shows an algorithm of extracting regular expression from information and ~\cite{Babbar:2010:CBA:1871840.1871848} presents another extraction algorithm for noisy unstructured text.
